---
folder: Getting Started
title: Progress
icon: üèÉ 
layout: ../../layouts/markdown-layout.astro
index: 5
description: The last step is to choose a form of progress, to make the scene (and the dream) work
---
```twoslash include main
import { FC } from "react";
import { Canvas } from "@react-three/fiber";
import { useRegister, helpers, orchestrate } from "jongleur";
import { Vector3 } from "three";

const clips = orchestrate(
  // The `Base`
  {
    one: {
      opacity: 0,
      config: { damping: false },
    },
    two: { position: new Vector3(0, 0, 0) },
    // NOTE: New object for the showcase
    three: {
      intensity: 0, 
      position: new Vector3(0, 0, 0)
    }
  },
  // The `Keyframes`
  {
    one: {
      1: { opacity: helpers.state(1) },
    },
    two: {
      0.5: { position: helpers.inherit },
      1: {
        position: helpers.state(
            new Vector3(1, 1, 1),
            "ease-in-out"
        ),
      },
    },
    three: {}
  },
  // The `Config`
  {
    damping: true,
    interpolation: "linear",
  }
);
```

import { Collapsible } from "@components/collapsible";
import Alert from "@components/alerts.astro";

Once you defined the scene and registered the moving parts, there is only one step left. Provide a form of progress. On this page, three forms of progress will be covered. First of all *time progress* and then *scroll progress*. In the end, we will also see how you can implement your own progress mechanism.

<Alert type="info">
The examples here are based on the same `clips` store, that was initialized in the [previous page](./progress). Be sure to check out that part of the guide first...
</Alert>

<Collapsible client:load title="This is the setup I am talking about">

```tsx twoslash
// @include: main

const App: FC = () => {
  const register = useRegister(clips);
  
  return (
      <Canvas>
        <mesh ref={register("two", "foo")}>
          <boxGeometry args={[1, 1, 1]} />
          <meshStandardMaterial color={"orange"} />
        </mesh>
        <group position={[1, 0, 1]}>
          <mesh ref={register("two", "bar")}>
            <boxGeometry args={[1, 1, 1]} />
            <meshStandardMaterial color={"blue"} />
          </mesh>
        </group>
        <pointLight ref={register("three")} />
      </Canvas>
  );
};


```

</Collapsible>


## Time progress

Perhaps the simplest form of progress, is time progress. This progress just continuously updates the scene, either with looping or else as a one-shot playback:


```tsx twoslash {1, 4-6, 16} 
// @include: main

// ---cut---
import { useTimeProgress } from "jongleur";

const TimeProgress = () => {
  // Second parameter (5) is the length of playback in seconds
  // Third parameters (true) controls scrolling behavior
  useTimeProgress(clips, 5, true);
  
  return null;
}

const App: FC = () => {
  const register = useRegister(clips);
  
  return (
      <Canvas>
        <TimeProgress />
        {/* ... */}
      </Canvas>
  );
};
```

<Alert type="warn">
The component that calls the `useTimeProgress` hook **must** be used inside of a `Canvas` Component since it uses the [useFrame](https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe) hook from r3f.
</Alert>

## Scroll Progress

The most prominent use case of *jongleur* is to connect the keyframe definitions to a scroll pane. This is similar to [`ScrollControls`](https://github.com/pmndrs/drei#scrollcontrols) of `@react-three/drei`. Additionally, a range of useful utility components is also exposed, to make building these scenes even more enjoyable. All Scroll related components are imported via a single Object `Scroll`:

```twoslash include scroll
import { Scroll } from "jongleur";
```

```ts twoslash
// hover `Scroll` to see the objects
// @include: scroll
```

### `Scroll.Controls`





